class Act4Model2Reporter
  
  def self.model_name
    "Three flower pot model"
  end
  
  @@fields = [
    :times_run,
    :success,
    :successes_array,
    :first_success,
    :total_successes,
    :total_failures,
    :mountain_steps,
    :info_tool_use
    ]
  @@fields.each { |field| attr_reader field }
    
  @@numFields = @@fields.length
  
  def self.num_fields
    @@numFields
  end
  
  def self.headers
    return [
      'Model 4:2: Times run',
      'Model 4:2: Ever succeeded',
      'Model 4:2: Successes array',
      'Model 4:2: First success',
      'Model 4:2: Total successes',
      'Model 4:2: Total failures',
      'Model 4:2: Max mountain height step per run',
      'Model 4:2: Times magnifying glass used',
    ]
  end
  
  def self.report_header
    headers.map{|h| "<th>" + h.to_s + "</th>" }.join('')
  end
  
  def row_values
    return [
      @times_run,
      @success,
      @successes_array,
      @first_success,
      @total_successes,
      @total_failures,
      @mountain_steps,
      @info_tool_use
    ]
  end
  
  def report_row
    row_values.map{|v| "<td>" + v.to_s + "</td>" }.join('')
  end
  
  def initialize(model)
    modelActivityData = model.modelActivityData
    if modelActivityData
      parseModelActivityData(modelActivityData)
    else
      Util.log("FlowerPotModelReporter: Model #{model} doesn't have model activity data")
    end
  end
  
  
  
  def parseModelActivityData(modelActivityData)
    modelData = calcModelData(modelActivityData)
    successArray = modelData[0]
    mountainStepsArray = modelData[1]
    infoToolArray = modelData[2]
    
    @times_run = modelActivityData.modelRuns.length
    @successes_array = successArray.inspect
    @first_success = successArray.index("success") ? successArray.index("success") + 1 : ""
    @total_successes = successArray.select { |success| success == "success" }.length
    @total_failures = successArray.select { |success| success == "failed" }.length
    @success = @total_successes > 0
    @mountain_steps = mountainStepsArray.inspect
    @info_tool_use = infoToolArray.inject { |a, b| a + b } || 0
  end
  
  def calcModelData(modelActivityData)
    ci_added = modelActivityData.computationalInputs.detect{|c| c.name == "Agents added" }
    ci_success = modelActivityData.computationalInputs.detect{|c| c.name == "Success" }
    ci_info = modelActivityData.computationalInputs.detect{|c| c.name == "Info tool used" }
    ci_message = modelActivityData.computationalInputs.detect{|c| c.name == "Message shown" }
    ci_mountain = modelActivityData.computationalInputs.detect{|c| c.name == "Mountain height changed, Num agents alive" }
    
    successArray = []
    mountainArray = []
    infoToolArray = []
    modelActivityData.modelRuns.each do |modelRun|
      modelData = calcData(modelRun, ci_added, ci_success, ci_info, ci_message, ci_mountain)
      successArray << modelData[0]
      mountainArray << modelData[1]
      infoToolArray << modelData[2]
    end
    [successArray, mountainArray, infoToolArray]
  end

  def calcData(modelRun, ci_added, ci_success, ci_info, ci_message, ci_mountain)
    success = "stopped"
    infoUse = 0
    maxMountainStep = 0
    lastMountainHeight = 0
    
    modelRun.computationalInputValues.each do |civ|  # we can only plant one, so we expect only one AgentsAdded civ
      if civ.reference == ci_success
        success = "success"
      elsif civ.reference == ci_message
        message = civ.values.get("0")
        if message =~ /extinct/
          success = "failed"
        elsif message =~ /evolve/
          success = "success"            # for students pre success flag
        end
      elsif civ.reference == ci_mountain
        mountainHeight = civ.values.get("0")
        mountainStep = (mountainHeight.to_i - lastMountainHeight.to_i).abs
        maxMountainStep = mountainStep if (mountainStep > maxMountainStep)
        lastMountainHeight = mountainHeight
      elsif civ.reference == ci_info
        infoUse = infoUse + 1
      end
    end
    
    [success, maxMountainStep, infoUse]
  end
 
end
